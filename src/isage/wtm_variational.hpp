// Header for word-based topic models

#ifndef ISAGE_WTM_VARIATIONAL_H_
#define ISAGE_WTM_VARIATIONAL_H_

#include "concrete.hpp"
#include "dmc.hpp"
#include "mathops.hpp"
#include "util.hpp"
#include "wtm.hpp"

#include <fstream>
#include <iostream>
#include "stdlib.h"
#include <time.h>

// for pair
#include "map"
#include <utility>
#include <unordered_set>
#include <string>
#include <vector>

#include <fstream>
#include <boost/algorithm/string.hpp>
#include <boost/bind.hpp>
#include <boost/serialization/unordered_map.hpp>
#include <boost/serialization/vector.hpp>

#include <gsl/gsl_rng.h>
#include <gsl/gsl_sf_exp.h>

namespace isage {
  namespace wtm {
    struct UniformHyperSeedWeightedInitializer {
    private:
      int nt_;
      double inv_nt_;
      double tu_;
      double t_;
    public:
      UniformHyperSeedWeightedInitializer(int num_topics, double topic_usage_weight, double topic_weight) : nt_(num_topics), tu_(topic_usage_weight), t_(topic_weight) {
	inv_nt_ = 1.0/(double)nt_;
      }
      std::vector<double> assignment() {
	return std::vector<double>(nt_, inv_nt_);
      }
      std::vector<double> topic(const std::vector<double>& hyper) {
	return isage::util::sum(hyper, std::vector<double>(hyper.size(), t_/(double)hyper.size()));
      }
      std::vector<double> usage(const std::vector<double>& hyper) {
	return isage::util::sum(hyper, std::vector<double>(hyper.size(), tu_/(double)hyper.size()));
      }
    };
    
    /**
     * Variational inference for word topic models.
     * This assumes that each observation is generated by a
     * categorical (discrete) distribution with a general
     * exponential family parametrization.
     */
    template <typename D, typename W, typename TopicType>
    class DiscreteVariational {
    private:
      typedef Vocabulary<W> V;
      typedef DiscreteLDA<W, TopicType > M;
      const int num_docs_;

      //std::vector< std::vector< int> >  assignments;

      std::vector< std::vector< double > > var_topic_params_;
      std::vector< std::vector< double > > var_topic_usage_params_;
      std::vector< std::vector< std::vector< double > > > var_assignment_params_;

      // the model itself
      M* model_;
      Corpus<D>* corpus_;
      V* vocab_;

      int num_topics_;

      dmc::gdmc topic_dmc_;
      dmc::gdmc word_dmc_;
    
      int current_word_index = -1;

    public:
      DiscreteVariational<D, W, TopicType>(M* model, Corpus<D>* corpus, V* vocab) :
      num_docs_(corpus->num_docs()), model_(model), corpus_(corpus), vocab_(vocab), 
	num_topics_(model->num_topics()) {
	word_dmc_  = dmc::gdmc(vocab_->num_words(), model_->hyper_word(), model_->num_topics());
	topic_dmc_ = dmc::gdmc(model_->num_topics(), model_->hyper_theta(), num_docs_);
      }
      ~DiscreteVariational() {
      }

      const std::vector<std::vector<std::vector< double> > >& var_assignment_params() {
	return var_assignment_params_;
      }
      const std::vector<std::vector<double> > var_topic_params() {
	return var_topic_params_;
      }
      const std::vector<std::vector<double> > var_topic_usage_params() {
	return var_topic_usage_params_;
      }

      template <typename VariationalInitializer>
      void init(VariationalInitializer vi) {
	for(int d = 0; d < num_docs_; d++) {
	  const int nw = ((*corpus_)[d]).num_words();
	  var_topic_usage_params_.push_back(vi.usage(model_->hyper_theta()));
	  var_assignment_params_.push_back(std::vector<std::vector<double> >(nw, vi.assignment())); 
	  //assignments.push_back(std::vector<int>(nw));
	}
	for(int t = 0; t < model_->num_topics(); t++) {
	  var_topic_params_.push_back(vi.topic(model_->hyper_word()));
	}
      }

      void update_var_assignments(int doc_index, int word_index, int word) {
	// this needs to call digamma:
	std::vector<double> grad = word_dmc_.grad_log_partition();
	isage::util::sum_in_x(grad, topic_dmc_.grad_log_partition());
	std::for_each(grad.begin(), grad.end(),
		      boost::bind(gsl_sf_exp, _1));
	
	// exp { digamma( hyper_i ) - digamma( hyper:sum ) }
	// and then renormalize
      }

      void update_usage(int doc_index) {
      }

      void update_topics(int topic_index) {
      }

      void learn() {
	//	for(int iteration = iter_offset; iteration < sample_strategy->num_iterations + iter_offset; iteration++) {
	for(int di = 0; di < num_docs_; ++di){
	  D doc = (*corpus_)[di];
	  const int num_w = doc.num_words();
	  for(int wi = 0; wi < num_w; ++wi){
	    //get word
	    const int word = vocab_->index(doc[wi]);
	    update_var_assignments(di, wi, word);
	  }
	  update_usage(di);
	}
	for(int ti = 0; ti < num_topics_; ++ti) {
	  update_topics(ti);
	}
      }
    };
  }
}

#endif
